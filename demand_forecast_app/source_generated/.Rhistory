# 2.0 PROCESSED DATA ----
con <- dbConnect(RSQLite::SQLite(), "../data/bikes_database.db")
bikes_tbl <- tbl(con, "bikes")
bikeshops_tbl <- tbl(con, "bikeshops")
orderlines_tbl <- tbl(con, "orderlines")
processed_data_tbl <- orderlines_tbl %>%
left_join(bikeshops_tbl, by = c("customer.id" = "bikeshop.id")) %>%
left_join(bikes_tbl, by = c("product.id" = "bike.id")) %>%
mutate(extended_price = quantity * price) %>%
collect()
processed_data_tbl <- processed_data_tbl %>%
mutate(order.date = ymd(order.date)) %>%
separate(location, into = c("city", "state"), sep = ", ") %>%
separate(description,
into = c("category_1", "category_2", "frame_material"),
sep = " - ") %>%
select(order.date, order.id, order.line, state, quantity, price,
extended_price, category_1:frame_material, bikeshop.name)
dbDisconnect(con)
# 3.1 DATA MANIPULATION ----
time_unit <- "quarter"
time_plot_tbl <- processed_data_tbl %>%
mutate(date = floor_date(order.date, unit = time_unit)) %>%
group_by(date) %>%
summarize(total_sales = sum(extended_price)) %>%
ungroup() %>%
mutate(label_text = str_glue("Date: {date}
Revenue: {scales::dollar(total_sales)}"))
time_plot_tbl
aggregate_time_series <- function(data, time_unit = "month") {
output_tbl <- data %>%
mutate(date = floor_date(order.date, unit = time_unit)) %>%
group_by(date) %>%
summarize(total_sales = sum(extended_price)) %>%
ungroup() %>%
mutate(label_text = str_glue("Date: {date}
Revenue: {scales::dollar(total_sales)}"))
return(output_tbl)
}
processed_data_tbl %>%
aggregate_time_series(time_unit = "day")
data <- processed_data_tbl %>%
aggregate_time_series("month")
g <- data %>%
ggplot(aes(date, total_sales)) +
geom_line(color = "#2c3e50") +
geom_point(aes(text = label_text), color = "#2c3e50", size = 0.1) +
geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
expand_limits(y = 0) +
scale_y_continuous(labels = scales::dollar_format()) +
labs(x = "", y = "")
ggplotly(g, tooltip = "text")
plot_time_series <- function(data) {
g <- data %>%
ggplot(aes(date, total_sales)) +
geom_line(color = "#2c3e50") +
geom_point(aes(text = label_text), color = "#2c3e50", size = 0.1) +
geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
expand_limits(y = 0) +
scale_y_continuous(labels = scales::dollar_format()) +
labs(x = "", y = "")
ggplotly(g, tooltip = "text")
}
processed_data_tbl %>%
aggregate_time_series(time_unit = "quarter") %>%
plot_time_series()
data <- processed_data_tbl %>%
aggregate_time_series(time_unit = "year")
data %>% tk_index() %>%
# tk_get_timeseries_signature() convers the timestamp information (index) into a data frame of key
# information about that time series index.  I call this signature, because it's unique to the
# pattern within the time series you are interested.
tk_get_timeseries_signature()
# tk_get_timeseries_summary() Returns a data frame with summary information about the time series index.
# for Units vs scale:
# Units- Think of the units as the smallest part of the time stamp.  For "2011-01-01" the unit is days.
# Scale- Think of scale as a measure between two observations.  If every observation is spaced 1 month apart,
# the scale is month.
data %>% tk_index() %>% tk_get_timeseries_summary()
# tk_get_timeseries_unit_frequency() is a helper function which returns the number of seconds between
# different time scales.  Anything less than the value gets the preceding time scale. (e.g. if
# median diff= 50, the scale returned is "sec" for seconds)
tk_get_timeseries_unit_frequency()
# tk_get_timeseries_variables() returns the column name of the time stamp data
data %>% tk_get_timeseries_variables()
# tk_augment_timeseries_signature() is a helper function to simplify the steps to adding time series signature
# columns to a data frame.
data %>% tk_augment_timeseries_signature()
train_tbl <- data %>%
tk_augment_timeseries_signature()
# Future data
future_data_tbl <- data %>%
tk_index() %>%
# tk_make_future_timeseries() helps in making future time stamps that extend at the
# same periodicity of the current time stamp scale.
tk_make_future_timeseries(length_out = 12, inspect_weekdays = TRUE, inspect_months = TRUE) %>%
tk_get_timeseries_signature()
seed <- 123
set.seed(seed)
model_xgboost <- boost_tree(
mode = "regression",
mtry = 20,
trees = 500,
min_n = 3,
tree_depth = 8,
learn_rate = 0.01,
loss_reduction = 0.01
) %>%
set_engine(engine = "xgboost") %>%
fit.model_spec(total_sales ~ ., data = train_tbl %>% select(-date, -label_text, -diff))
future_data_tbl
prediction_tbl <- predict(model_xgboost, new_data = future_data_tbl) %>%
bind_cols(future_data_tbl) %>%
select(.pred, index) %>%
rename(total_sales = .pred,
date = index) %>%
mutate(label_text = str_glue("Date: {date}\nRevenue: {scales::dollar(total_sales)}")) %>%
add_column(key = "Prediction")
output_tbl <- data %>%
add_column(key = "Actual") %>%
bind_rows(prediction_tbl)
output_tbl
generate_forecast <- function(data, n_future = 12, seed = NULL) {
train_tbl <- data %>%
tk_augment_timeseries_signature()
# Future data
future_data_tbl <- data %>%
tk_index() %>%
# tk_make_future_timeseries() helps in making future time stamps that extend at the
# same periodicity of the current time stamp scale.
tk_make_future_timeseries(length_out = n_future, inspect_weekdays = TRUE, inspect_months = TRUE) %>%
tk_get_timeseries_signature()
time_scale <- data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
pull(scale)
if(time_scale == "year"){
# Setup linear regression for year
model <- linear_reg(mode = "regression") %>%
set_engine(engine = "lm") %>%
# you can use either fit or fit.model_spec(), the latter shows you the arguments.
fit.model_spec(formula = total_sales ~ ., data = train_tbl %>% select(total_sales, index.num))
} else {
seed <- seed
set.seed(seed)
model <- boost_tree(
mode = "regression",
mtry = 20,
trees = 500,
min_n = 3,
tree_depth = 8,
learn_rate = 0.01,
loss_reduction = 0.01
) %>%
set_engine(engine = "xgboost") %>%
fit.model_spec(total_sales ~ ., data = train_tbl %>% select(-date, -label_text, -diff))
}
prediction_tbl <- predict(model, new_data = future_data_tbl) %>%
bind_cols(future_data_tbl) %>%
select(.pred, index) %>%
rename(total_sales = .pred,
date = index) %>%
mutate(label_text = str_glue("Date: {date}\nRevenue: {scales::dollar(total_sales)}")) %>%
add_column(key = "Prediction")
output_tbl <- data %>%
add_column(key = "Actual") %>%
bind_rows(prediction_tbl)
return(output_tbl)
}
# test function through workflow process
processed_data_tbl %>%
aggregate_time_series(time_unit = "month") %>%
generate_forecast(n_future = 12, seed = 123)
data <- processed_data_tbl %>%
aggregate_time_series(time_unit = "month") %>%
generate_forecast(n_future = 12, seed = 123)
g <- data %>%
ggplot(aes(x= date, y = total_sales, color = key)) +
geom_line() +
# Hack for tool tip text later
geom_point(aes(text = label_text), size = 0.1) +
geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
scale_color_tq() +
scale_y_continuous(labels = scales::dollar_format()) +
labs(x = "", y = "")
ggplotly(g, tooltip = "text")
data <- processed_data_tbl %>%
aggregate_time_series(time_unit = "year") %>%
generate_forecast(n_future = 1, seed = 123)
plot_forecast <- function(data) {
# Yearly - LM Smoother
time_scale <- data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
pull(scale)
# If only 1 prediction - convert to points
n_predictions <- data %>%
filter(key == "Prediction") %>%
nrow()
g <- data %>%
ggplot(aes(x= date, y = total_sales, color = key)) +
geom_line() +
# Hack for tool tip text later
# removed geom_point as we updated to incorporate for one point option below
#geom_point(aes(text = label_text), size = 0.1) +
# removed smoother here as we updated to incorporate lm as well.
#geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
scale_color_tq() +
scale_y_continuous(labels = scales::dollar_format()) +
expand_limits(y = 0) +
labs(x = "", y = "")
# Yearly - LM Smoother
if(time_scale == "year") {
g <- g +
geom_smooth(method = "lm")
} else {
g <- g +
geom_smooth(method = "loess", span = 0.2)
}
# Only 1 prediction
if (n_predictions == 1) {
g <- g +
geom_point(aes(text = label_text), size = 1)
} else {
g <- g +
geom_point(aes(text = label_text), size = 0.01)
}
ggplotly(g, tooltip = "text")
}
# test with pipeline:
processed_data_tbl %>%
aggregate_time_series(time_unit = "month") %>%
generate_forecast(n_future = 12, seed = 123) %>%
plot_forecast()
dump(c("aggregate_time_series", "plot_time_series", "generate_forecast", "plot_forecast"),
file = "scripts/04_demand_forecast.R")
dump(c("aggregate_time_series", "plot_time_series", "generate_forecast", "plot_forecast"),
file = "../scripts/04_demand_forecast.R")
rsconnect::deployApp(appDir = getwd(),      # Deploys the current working directory
appName = "sales_dashboard_forecast_app",
account = "estevanfisk")
# Core
library(tidyverse)
library(tidyquant)
# Interactive Visualizations
library(plotly)
# Modeling Libraries
library(parsnip)
library(timetk)
# Database
library(odbc)
library(RSQLite)
# 2.0 PROCESSED DATA ----
con <- dbConnect(RSQLite::SQLite(), "../data/bikes_database.db")
bikes_tbl <- tbl(con, "bikes")
bikeshops_tbl <- tbl(con, "bikeshops")
orderlines_tbl <- tbl(con, "orderlines")
processed_data_tbl <- orderlines_tbl %>%
left_join(bikeshops_tbl, by = c("customer.id" = "bikeshop.id")) %>%
left_join(bikes_tbl, by = c("product.id" = "bike.id")) %>%
mutate(extended_price = quantity * price) %>%
collect()
processed_data_tbl <- processed_data_tbl %>%
mutate(order.date = ymd(order.date)) %>%
separate(location, into = c("city", "state"), sep = ", ") %>%
separate(description,
into = c("category_1", "category_2", "frame_material"),
sep = " - ") %>%
select(order.date, order.id, order.line, state, quantity, price,
extended_price, category_1:frame_material, bikeshop.name)
View(processed_data_tbl)
dbDisconnect(con)
# 3.1 DATA MANIPULATION ----
time_unit <- "quarter"
time_plot_tbl <- processed_data_tbl %>%
mutate(date = floor_date(order.date, unit = time_unit)) %>%
group_by(date) %>%
summarize(total_sales = sum(extended_price)) %>%
ungroup() %>%
mutate(label_text = str_glue("Date: {date}
Revenue: {scales::dollar(total_sales)}"))
View(time_plot_tbl)
time_plot_tbl
aggregate_time_series <- function(data, time_unit = "month") {
output_tbl <- data %>%
mutate(date = floor_date(order.date, unit = time_unit)) %>%
group_by(date) %>%
summarize(total_sales = sum(extended_price)) %>%
ungroup() %>%
mutate(label_text = str_glue("Date: {date}
Revenue: {scales::dollar(total_sales)}"))
return(output_tbl)
}
processed_data_tbl %>%
aggregate_time_series(time_unit = "day")
data <- processed_data_tbl %>%
aggregate_time_series("month")
g <- data %>%
ggplot(aes(date, total_sales)) +
geom_line(color = "#2c3e50") +
geom_point(aes(text = label_text), color = "#2c3e50", size = 0.1) +
geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
expand_limits(y = 0) +
scale_y_continuous(labels = scales::dollar_format()) +
labs(x = "", y = "")
ggplotly(g, tooltip = "text")
plot_time_series <- function(data) {
g <- data %>%
ggplot(aes(date, total_sales)) +
geom_line(color = "#2c3e50") +
geom_point(aes(text = label_text), color = "#2c3e50", size = 0.1) +
geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
expand_limits(y = 0) +
scale_y_continuous(labels = scales::dollar_format()) +
labs(x = "", y = "")
ggplotly(g, tooltip = "text")
}
processed_data_tbl %>%
aggregate_time_series(time_unit = "quarter") %>%
plot_time_series()
data <- processed_data_tbl %>%
aggregate_time_series(time_unit = "year")
View(data)
data %>% tk_index() %>%
# tk_get_timeseries_signature() convers the timestamp information (index) into a data frame of key
# information about that time series index.  I call this signature, because it's unique to the
# pattern within the time series you are interested.
tk_get_timeseries_signature()
View(data)
View(data)
# tk_get_timeseries_summary() Returns a data frame with summary information about the time series index.
# for Units vs scale:
# Units- Think of the units as the smallest part of the time stamp.  For "2011-01-01" the unit is days.
# Scale- Think of scale as a measure between two observations.  If every observation is spaced 1 month apart,
# the scale is month.
data %>% tk_index() %>% tk_get_timeseries_summary()
# tk_get_timeseries_unit_frequency() is a helper function which returns the number of seconds between
# different time scales.  Anything less than the value gets the preceding time scale. (e.g. if
# median diff= 50, the scale returned is "sec" for seconds)
tk_get_timeseries_unit_frequency()
# tk_get_timeseries_variables() returns the column name of the time stamp data
data %>% tk_get_timeseries_variables()
# tk_augment_timeseries_signature() is a helper function to simplify the steps to adding time series signature
# columns to a data frame.
data %>% tk_augment_timeseries_signature()
train_tbl <- data %>%
tk_augment_timeseries_signature()
View(train_tbl)
# Future data
future_data_tbl <- data %>%
tk_index() %>%
# tk_make_future_timeseries() helps in making future time stamps that extend at the
# same periodicity of the current time stamp scale.
tk_make_future_timeseries(length_out = 12, inspect_weekdays = TRUE, inspect_months = TRUE) %>%
tk_get_timeseries_signature()
View(future_data_tbl)
View(train_tbl)
View(future_data_tbl)
View(train_tbl)
View(train_tbl)
seed <- 123
set.seed(seed)
model_xgboost <- boost_tree(
mode = "regression",
mtry = 20,
trees = 500,
min_n = 3,
tree_depth = 8,
learn_rate = 0.01,
loss_reduction = 0.01
) %>%
set_engine(engine = "xgboost") %>%
fit.model_spec(total_sales ~ ., data = train_tbl %>% select(-date, -label_text, -diff))
future_data_tbl
View(future_data_tbl)
prediction_tbl <- predict(model_xgboost, new_data = future_data_tbl) %>%
bind_cols(future_data_tbl) %>%
select(.pred, index) %>%
rename(total_sales = .pred,
date = index) %>%
mutate(label_text = str_glue("Date: {date}\nRevenue: {scales::dollar(total_sales)}")) %>%
add_column(key = "Prediction")
View(prediction_tbl)
output_tbl <- data %>%
add_column(key = "Actual") %>%
bind_rows(prediction_tbl)
output_tbl
View(output_tbl)
generate_forecast <- function(data, n_future = 12, seed = NULL) {
train_tbl <- data %>%
tk_augment_timeseries_signature()
# Future data
future_data_tbl <- data %>%
tk_index() %>%
# tk_make_future_timeseries() helps in making future time stamps that extend at the
# same periodicity of the current time stamp scale.
tk_make_future_timeseries(length_out = n_future, inspect_weekdays = TRUE, inspect_months = TRUE) %>%
tk_get_timeseries_signature()
time_scale <- data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
pull(scale)
if(time_scale == "year"){
# Setup linear regression for year
model <- linear_reg(mode = "regression") %>%
set_engine(engine = "lm") %>%
# you can use either fit or fit.model_spec(), the latter shows you the arguments.
fit.model_spec(formula = total_sales ~ ., data = train_tbl %>% select(total_sales, index.num))
} else {
seed <- seed
set.seed(seed)
model <- boost_tree(
mode = "regression",
mtry = 20,
trees = 500,
min_n = 3,
tree_depth = 8,
learn_rate = 0.01,
loss_reduction = 0.01
) %>%
set_engine(engine = "xgboost") %>%
fit.model_spec(total_sales ~ ., data = train_tbl %>% select(-date, -label_text, -diff))
}
prediction_tbl <- predict(model, new_data = future_data_tbl) %>%
bind_cols(future_data_tbl) %>%
select(.pred, index) %>%
rename(total_sales = .pred,
date = index) %>%
mutate(label_text = str_glue("Date: {date}\nRevenue: {scales::dollar(total_sales)}")) %>%
add_column(key = "Prediction")
output_tbl <- data %>%
add_column(key = "Actual") %>%
bind_rows(prediction_tbl)
return(output_tbl)
}
# test function through workflow process
processed_data_tbl %>%
aggregate_time_series(time_unit = "month") %>%
generate_forecast(n_future = 12, seed = 123)
data <- processed_data_tbl %>%
aggregate_time_series(time_unit = "month") %>%
generate_forecast(n_future = 12, seed = 123)
View(data)
View(data)
g <- data %>%
ggplot(aes(x= date, y = total_sales, color = key)) +
geom_line() +
# Hack for tool tip text later
geom_point(aes(text = label_text), size = 0.1) +
geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
scale_color_tq() +
scale_y_continuous(labels = scales::dollar_format()) +
labs(x = "", y = "")
ggplotly(g, tooltip = "text")
data <- processed_data_tbl %>%
aggregate_time_series(time_unit = "year") %>%
generate_forecast(n_future = 1, seed = 123)
plot_forecast <- function(data) {
# Yearly - LM Smoother
time_scale <- data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
pull(scale)
# If only 1 prediction - convert to points
n_predictions <- data %>%
filter(key == "Prediction") %>%
nrow()
g <- data %>%
ggplot(aes(x= date, y = total_sales, color = key)) +
geom_line() +
# Hack for tool tip text later
# removed geom_point as we updated to incorporate for one point option below
#geom_point(aes(text = label_text), size = 0.1) +
# removed smoother here as we updated to incorporate lm as well.
#geom_smooth(method = "loess", span = 0.2) +
theme_tq() +
scale_color_tq() +
scale_y_continuous(labels = scales::dollar_format()) +
expand_limits(y = 0) +
labs(x = "", y = "")
# Yearly - LM Smoother
if(time_scale == "year") {
g <- g +
geom_smooth(method = "lm")
} else {
g <- g +
geom_smooth(method = "loess", span = 0.2)
}
# Only 1 prediction
if (n_predictions == 1) {
g <- g +
geom_point(aes(text = label_text), size = 1)
} else {
g <- g +
geom_point(aes(text = label_text), size = 0.01)
}
ggplotly(g, tooltip = "text")
}
# test with pipeline:
processed_data_tbl %>%
aggregate_time_series(time_unit = "month") %>%
generate_forecast(n_future = 12, seed = 123) %>%
plot_forecast()
dump(c("aggregate_time_series", "plot_time_series", "generate_forecast", "plot_forecast"),
file = "../scripts/04_demand_forecast.R")
